// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0649
#pragma warning disable 1522
#pragma warning disable 0414
#pragma warning disable 0219
#pragma warning disable 0109


namespace Quantum {
  using System;
  using System.Collections.Generic;
  using System.Runtime.InteropServices;
  using Photon.Deterministic;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Optional = Quantum.Inspector.OptionalAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  
  public enum EnumPlayerState : int {
    None,
    Idle,
    Run,
    Attack,
    BeAttack,
    Jump,
    Fall,
    Stand,
  }
  public enum RoundState : int {
    LoadMap,
    LoadScene,
    LoadPlayer,
    Enter,
    Ready,
    Run,
    Finish,
    Ended,
  }
  public enum SecondRoundState : int {
    Ready,
    Run,
    EndAnimation,
    End,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    PickThrowButton = 1 << 0,
    JumpButton = 1 << 1,
    LeftButton = 1 << 2,
    RightButton = 1 << 3,
  }
  public static unsafe partial class InputButtons_ext {
    public static Boolean HasFlag(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [System.ObsoleteAttribute("This type will be removed with 2.1 release. Use instance methods instead.")]
  public static unsafe partial class BitSet {
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet1024* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 1024);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet1024* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 1024);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet1024* set) {
      Native.Utils.Clear(((UInt64*)set), 128);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet1024* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet128* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet128* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet128* set) {
      Native.Utils.Clear(((UInt64*)set), 16);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet128* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet2048* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet2048* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet2048* set) {
      Native.Utils.Clear(((UInt64*)set), 256);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet2048* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet256* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet256* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet256* set) {
      Native.Utils.Clear(((UInt64*)set), 32);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet256* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet4096* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet4096* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet4096* set) {
      Native.Utils.Clear(((UInt64*)set), 512);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet4096* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet512* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet512* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet512* set) {
      Native.Utils.Clear(((UInt64*)set), 64);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet512* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [System.ObsoleteAttribute("Use instance Set method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Set(BitSet8* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 8);
      (((UInt64*)set)[bit/64]) |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Clear(BitSet8* set, Int32 bit) {
      Assert.Check(bit >= 0 && bit < 8);
      (((UInt64*)set)[bit/64]) &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ClearAll(BitSet8* set) {
      Native.Utils.Clear(((UInt64*)set), 8);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead. This method will be removed with 2.1 release.")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Boolean IsSet(BitSet8* set, Int32 bit) {
      return ((((UInt64*)set)[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet1024 {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[16];
    public const Int32 BitsSize = 1024;
    public Int32 Length {
      get {
        return 1024;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet1024*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 1024, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet1024* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet1024* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet1024* set) {
      Native.Utils.Clear(&set->bits[0], 128);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet1024* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet1024 FromArray(UInt64[] values) {
      Assert.Always(16 == values.Length);
      BitSet1024 result = default;
      for (int i = 0; i < 16; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 1024);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 1024);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 128);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 37;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 16);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet1024*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 16);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet128* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet128* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet128* set) {
      Native.Utils.Clear(&set->bits[0], 16);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet128* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 41;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet2048* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet2048* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet2048* set) {
      Native.Utils.Clear(&set->bits[0], 256);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet2048* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 43;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet256* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet256* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet256* set) {
      Native.Utils.Clear(&set->bits[0], 32);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet256* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 47;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet4096* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet4096* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet4096* set) {
      Native.Utils.Clear(&set->bits[0], 512);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet4096* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 53;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet512* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet512* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet512* set) {
      Native.Utils.Clear(&set->bits[0], 64);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet512* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 59;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet8 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[1];
    public const Int32 BitsSize = 8;
    public Int32 Length {
      get {
        return 8;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet8*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 8, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet8* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet8* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet8* set) {
      Native.Utils.Clear(&set->bits[0], 8);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet8* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet8 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length);
      BitSet8 result = default;
      for (int i = 0; i < 1; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 8);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 8);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 61;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet8*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct QStringUtf8_64 : IQStringUtf8, IEquatable<QStringUtf8_64> {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private UInt16 byteCount;
    [FieldOffset(2)]
    [FixedBufferDynamicLength("byteCount")]
    private fixed Byte bytes[62];
    public const int MaxByteCount = 62;
    public QStringUtf8_64(String str) {
      QStringUtf8.ConstructFrom(str, MaxByteCount, out this);
    }
    public int Length {
      get {
        return QStringUtf8.GetLength(ref this);
      }
    }
    public int ByteCount {
      get {
        return byteCount;
      }
    }
    public override System.String ToString() {
      return QStringUtf8.GetString(ref this);
    }
    public static Boolean CanHold(String str) {
      return QStringUtf8.CanHold(str, MaxByteCount);
    }
    Int32 IQStringUtf8.CompareOrdinal(byte* bytes, UInt16 byteCount) {
      return QStringUtf8.CompareOrdinal(ref this, bytes, byteCount);
    }
    public Int32 CompareOrdinal(String str) {
      return QStringUtf8.CompareOrdinal(ref this, str);
    }
    public static implicit operator QStringUtf8_64(String str) {
      return new QStringUtf8_64(str);
    }
    public static implicit operator String(QStringUtf8_64 str) {
      return str.ToString();
    }
    public override Boolean Equals(Object obj) {
      return QStringUtf8.AreEqual(ref this, obj);
    }
    public Boolean Equals(QStringUtf8_64 str) {
      return QStringUtf8.CompareOrdinal(ref this, str.bytes, str.byteCount) == 0;
    }
    public Boolean Equals<T>(ref T str)
      where T : unmanaged, IQStringUtf8 {
      return QStringUtf8.CompareOrdinal(ref this, ref str) == 0;
    }
    public Int32 CompareOrdinal<T>(ref T str)
      where T : unmanaged, IQStringUtf8 {
      return QStringUtf8.CompareOrdinal(ref this, ref str);
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 67;
        hash = hash * 31 + byteCount.GetHashCode();
        fixed (Byte* p = bytes) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, this.byteCount);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QStringUtf8_64*)ptr;
        serializer.Stream.Serialize(&p->byteCount);
        Assert.Always(p->byteCount <= 62);
        serializer.Stream.SerializeBuffer(&p->bytes[0], p->byteCount);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(CustomAnimatorBehaviour))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefCustomAnimatorBehaviour : IEquatable<AssetRefCustomAnimatorBehaviour>, IAssetRef<CustomAnimatorBehaviour> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefCustomAnimatorBehaviour(CustomAnimatorBehaviour value) {
      var r = default(AssetRefCustomAnimatorBehaviour);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefCustomAnimatorBehaviour other && Equals(other);
    }
    public Boolean Equals(AssetRefCustomAnimatorBehaviour other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefCustomAnimatorBehaviour a, AssetRefCustomAnimatorBehaviour b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefCustomAnimatorBehaviour a, AssetRefCustomAnimatorBehaviour b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 71;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefCustomAnimatorBehaviour*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(CustomAnimatorGraph))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefCustomAnimatorGraph : IEquatable<AssetRefCustomAnimatorGraph>, IAssetRef<CustomAnimatorGraph> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefCustomAnimatorGraph(CustomAnimatorGraph value) {
      var r = default(AssetRefCustomAnimatorGraph);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefCustomAnimatorGraph other && Equals(other);
    }
    public Boolean Equals(AssetRefCustomAnimatorGraph other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefCustomAnimatorGraph a, AssetRefCustomAnimatorGraph b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefCustomAnimatorGraph a, AssetRefCustomAnimatorGraph b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 73;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefCustomAnimatorGraph*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(GameAnimatorState))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefGameAnimatorState : IEquatable<AssetRefGameAnimatorState>, IAssetRef<GameAnimatorState> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefGameAnimatorState(GameAnimatorState value) {
      var r = default(AssetRefGameAnimatorState);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefGameAnimatorState other && Equals(other);
    }
    public Boolean Equals(AssetRefGameAnimatorState other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefGameAnimatorState a, AssetRefGameAnimatorState b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefGameAnimatorState a, AssetRefGameAnimatorState b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 79;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefGameAnimatorState*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(RoundConfig))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefRoundConfig : IEquatable<AssetRefRoundConfig>, IAssetRef<RoundConfig> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefRoundConfig(RoundConfig value) {
      var r = default(AssetRefRoundConfig);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefRoundConfig other && Equals(other);
    }
    public Boolean Equals(AssetRefRoundConfig other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefRoundConfig a, AssetRefRoundConfig b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefRoundConfig a, AssetRefRoundConfig b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 83;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefRoundConfig*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(SceneObjAnimationClip))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefSceneObjAnimationClip : IEquatable<AssetRefSceneObjAnimationClip>, IAssetRef<SceneObjAnimationClip> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefSceneObjAnimationClip(SceneObjAnimationClip value) {
      var r = default(AssetRefSceneObjAnimationClip);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefSceneObjAnimationClip other && Equals(other);
    }
    public Boolean Equals(AssetRefSceneObjAnimationClip other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefSceneObjAnimationClip a, AssetRefSceneObjAnimationClip b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefSceneObjAnimationClip a, AssetRefSceneObjAnimationClip b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 89;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefSceneObjAnimationClip*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GamePlayer {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public QBoolean IsEnter;
    [FieldOffset(28)]
    public QBoolean IsFinish;
    [FieldOffset(32)]
    public QBoolean IsLoadMap;
    [FieldOffset(36)]
    public QBoolean IsLoadPlayer;
    [FieldOffset(40)]
    public QBoolean IsLoadScene;
    [FieldOffset(20)]
    public PlayerRef Player;
    [FieldOffset(48)]
    public EntityRef PlayerEntity;
    [FieldOffset(0)]
    public Int32 avaterId;
    [FieldOffset(4)]
    public Int32 bodyColor;
    [FieldOffset(8)]
    public Int32 hairColor;
    [FieldOffset(12)]
    public Int32 hairId;
    [FieldOffset(16)]
    public Int32 headid;
    [FieldOffset(56)]
    public Int64 roleid;
    [FieldOffset(64)]
    public QStringUtf8_64 rolename;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 97;
        hash = hash * 31 + IsEnter.GetHashCode();
        hash = hash * 31 + IsFinish.GetHashCode();
        hash = hash * 31 + IsLoadMap.GetHashCode();
        hash = hash * 31 + IsLoadPlayer.GetHashCode();
        hash = hash * 31 + IsLoadScene.GetHashCode();
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + PlayerEntity.GetHashCode();
        hash = hash * 31 + avaterId.GetHashCode();
        hash = hash * 31 + bodyColor.GetHashCode();
        hash = hash * 31 + hairColor.GetHashCode();
        hash = hash * 31 + hairId.GetHashCode();
        hash = hash * 31 + headid.GetHashCode();
        hash = hash * 31 + roleid.GetHashCode();
        hash = hash * 31 + rolename.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GamePlayer*)ptr;
        serializer.Stream.Serialize(&p->avaterId);
        serializer.Stream.Serialize(&p->bodyColor);
        serializer.Stream.Serialize(&p->hairColor);
        serializer.Stream.Serialize(&p->hairId);
        serializer.Stream.Serialize(&p->headid);
        PlayerRef.Serialize(&p->Player, serializer);
        QBoolean.Serialize(&p->IsEnter, serializer);
        QBoolean.Serialize(&p->IsFinish, serializer);
        QBoolean.Serialize(&p->IsLoadMap, serializer);
        QBoolean.Serialize(&p->IsLoadPlayer, serializer);
        QBoolean.Serialize(&p->IsLoadScene, serializer);
        EntityRef.Serialize(&p->PlayerEntity, serializer);
        serializer.Stream.Serialize(&p->roleid);
        Quantum.QStringUtf8_64.Serialize(&p->rolename, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameRoundData {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(12)]
    [FramePrinter.PtrQListAttribute(typeof(PlayerRef))]
    private Ptr EndPlayersPtr;
    [FieldOffset(0)]
    public Int32 GameType;
    [FieldOffset(32)]
    public FP ReadyTime;
    [FieldOffset(4)]
    public Int32 RoundIndex;
    [FieldOffset(16)]
    [FramePrinter.PtrQListAttribute(typeof(EntityRef))]
    private Ptr SceneEntitysPtr;
    [FieldOffset(8)]
    public Int32 SecondRound;
    [FieldOffset(24)]
    public SecondRoundState SecondRoundState;
    [FieldOffset(40)]
    public FP SecondRoundTime;
    [FieldOffset(20)]
    public RoundState State;
    [FieldOffset(48)]
    public FP Timer;
    public QListPtr<PlayerRef> EndPlayers {
      get {
        return new QListPtr<PlayerRef>(EndPlayersPtr);
      }
      set {
        EndPlayersPtr = value.Ptr;
      }
    }
    public QListPtr<EntityRef> SceneEntitys {
      get {
        return new QListPtr<EntityRef>(SceneEntitysPtr);
      }
      set {
        SceneEntitysPtr = value.Ptr;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 101;
        hash = hash * 31 + EndPlayersPtr.GetHashCode();
        hash = hash * 31 + GameType.GetHashCode();
        hash = hash * 31 + ReadyTime.GetHashCode();
        hash = hash * 31 + RoundIndex.GetHashCode();
        hash = hash * 31 + SceneEntitysPtr.GetHashCode();
        hash = hash * 31 + SecondRound.GetHashCode();
        hash = hash * 31 + (Int32)SecondRoundState;
        hash = hash * 31 + SecondRoundTime.GetHashCode();
        hash = hash * 31 + (Int32)State;
        hash = hash * 31 + Timer.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      EndPlayersPtr = default;
      SceneEntitysPtr = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameRoundData*)ptr;
        serializer.Stream.Serialize(&p->GameType);
        serializer.Stream.Serialize(&p->RoundIndex);
        serializer.Stream.Serialize(&p->SecondRound);
        QList<PlayerRef>.Serialize(&p->EndPlayersPtr, serializer, PlayerRef.Serialize);
        QList<EntityRef>.Serialize(&p->SceneEntitysPtr, serializer, EntityRef.Serialize);
        serializer.Stream.Serialize((Int32*)&p->State);
        serializer.Stream.Serialize((Int32*)&p->SecondRoundState);
        FP.Serialize(&p->ReadyTime, serializer);
        FP.Serialize(&p->SecondRoundTime, serializer);
        FP.Serialize(&p->Timer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HurtBox {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPBounds2 bound;
    [FieldOffset(0)]
    public Int32 frameIndex;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 103;
        hash = hash * 31 + bound.GetHashCode();
        hash = hash * 31 + frameIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HurtBox*)ptr;
        serializer.Stream.Serialize(&p->frameIndex);
        FPBounds2.Serialize(&p->bound, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(48)]
    public FPVector2 Direction;
    [FieldOffset(0)]
    public Button JumpButton;
    [FieldOffset(12)]
    public Button LeftButton;
    [FieldOffset(24)]
    public Button PickThrowButton;
    [FieldOffset(36)]
    public Button RightButton;
    public const int MAX_COUNT = 8;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 107;
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + JumpButton.GetHashCode();
        hash = hash * 31 + LeftButton.GetHashCode();
        hash = hash * 31 + PickThrowButton.GetHashCode();
        hash = hash * 31 + RightButton.GetHashCode();
        return hash;
      }
    }
    public static Input Read(FrameSerializer serializer) {
      Input i = new Input();
      Serialize(&i, serializer);
      return i;
    }
    public static void Write(FrameSerializer serializer, Input i) {
      Serialize(&i, serializer);
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.PickThrowButton: return PickThrowButton.IsDown;
        case InputButtons.JumpButton: return JumpButton.IsDown;
        case InputButtons.LeftButton: return LeftButton.IsDown;
        case InputButtons.RightButton: return RightButton.IsDown;
      }
      return false;
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.PickThrowButton: return PickThrowButton.WasPressed;
        case InputButtons.JumpButton: return JumpButton.WasPressed;
        case InputButtons.LeftButton: return LeftButton.WasPressed;
        case InputButtons.RightButton: return RightButton.WasPressed;
      }
      return false;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        Button.Serialize(&p->JumpButton, serializer);
        Button.Serialize(&p->LeftButton, serializer);
        Button.Serialize(&p->PickThrowButton, serializer);
        Button.Serialize(&p->RightButton, serializer);
        FPVector2.Serialize(&p->Direction, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerState {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP Time;
    [FieldOffset(0)]
    public EnumPlayerState state;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 109;
        hash = hash * 31 + Time.GetHashCode();
        hash = hash * 31 + (Int32)state;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerState*)ptr;
        serializer.Stream.Serialize((Int32*)&p->state);
        FP.Serialize(&p->Time, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 976;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(112)]
    public GameRoundData CurrentGameRound;
    [FieldOffset(24)]
    public FP DeltaTime;
    [FieldOffset(56)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(8)]
    public AssetRefMap Map;
    [FieldOffset(32)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(680)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(16)]
    public BitSet8 PlayerLastConnectionState;
    [FieldOffset(0)]
    [FramePrinter.PtrQListAttribute(typeof(GamePlayer))]
    private Ptr PlayerListPtr;
    [FieldOffset(40)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public BitSet256 Systems;
    [FieldOffset(168)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 8)]
    private fixed Byte _input_[512];
    public QListPtr<GamePlayer> PlayerList {
      get {
        return new QListPtr<GamePlayer>(PlayerListPtr);
      }
      set {
        PlayerListPtr = value.Ptr;
      }
    }
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 64, 8); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 113;
        hash = hash * 31 + CurrentGameRound.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + PlayerListPtr.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      CurrentGameRound.ClearPointers(f, entity);
      PlayerListPtr = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        QList<GamePlayer>.Serialize(&p->PlayerListPtr, serializer, Quantum.GamePlayer.Serialize);
        AssetRefMap.Serialize(&p->Map, serializer);
        Quantum.BitSet8.Serialize(&p->PlayerLastConnectionState, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet256.Serialize(&p->Systems, serializer);
        Quantum.GameRoundData.Serialize(&p->CurrentGameRound, serializer);
        FixedArray<Input>.Serialize(p->input, serializer, Quantum.Input.Serialize);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct CustomAnimatorRuntimeVariable {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.CustomAnimatorRuntimeVariable.BOOLEANVALUE)]
    private QBoolean _BooleanValue;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.CustomAnimatorRuntimeVariable.FPVALUE)]
    private FP _FPValue;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.CustomAnimatorRuntimeVariable.INTEGERVALUE)]
    private Int32 _IntegerValue;
    [FieldOffset(0)]
    private Int32 _field_used_;
    public const Int32 FPVALUE = 1;
    public const Int32 INTEGERVALUE = 2;
    public const Int32 BOOLEANVALUE = 3;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public QBoolean* BooleanValue {
      get {
        fixed (QBoolean* p = &_BooleanValue) {
          if (_field_used_ != BOOLEANVALUE) {
            Native.Utils.Clear(p, 4);
            _field_used_ = BOOLEANVALUE;
          }
          return p;
        }
      }
    }
    public FP* FPValue {
      get {
        fixed (FP* p = &_FPValue) {
          if (_field_used_ != FPVALUE) {
            Native.Utils.Clear(p, 8);
            _field_used_ = FPVALUE;
          }
          return p;
        }
      }
    }
    public Int32* IntegerValue {
      get {
        fixed (Int32* p = &_IntegerValue) {
          if (_field_used_ != INTEGERVALUE) {
            Native.Utils.Clear(p, 4);
            _field_used_ = INTEGERVALUE;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 127;
        hash = hash * 31 + _BooleanValue.GetHashCode();
        hash = hash * 31 + _FPValue.GetHashCode();
        hash = hash * 31 + _IntegerValue.GetHashCode();
        hash = hash * 31 + _field_used_.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CustomAnimatorRuntimeVariable*)ptr;
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == BOOLEANVALUE) {
          QBoolean.Serialize(&p->_BooleanValue, serializer);
        }
        if (p->_field_used_ == FPVALUE) {
          FP.Serialize(&p->_FPValue, serializer);
        }
        if (p->_field_used_ == INTEGERVALUE) {
          serializer.Stream.Serialize(&p->_IntegerValue);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CustomAnimator : Quantum.IComponent {
    public const Int32 SIZE = 168;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    [FramePrinter.PtrQListAttribute(typeof(CustomAnimatorRuntimeVariable))]
    private Ptr AnimatorVariablesPtr;
    [FieldOffset(32)]
    [FramePrinter.PtrQListAttribute(typeof(AssetGuid))]
    private Ptr TriggeredStateBehavioursPtr;
    [FieldOffset(40)]
    public AssetRefCustomAnimatorGraph animatorGraph;
    [FieldOffset(0)]
    public Int32 animator_blend_count;
    [FieldOffset(4)]
    public Int32 current_state_id;
    [FieldOffset(36)]
    public QBoolean freeze;
    [FieldOffset(48)]
    public FP from_length;
    [FieldOffset(8)]
    public Int32 from_state_id;
    [FieldOffset(56)]
    public FP from_state_last_time;
    [FieldOffset(64)]
    public FP from_state_normalized_time;
    [FieldOffset(72)]
    public FP from_state_time;
    [FieldOffset(80)]
    public FP last_time;
    [FieldOffset(88)]
    public FP length;
    [FieldOffset(96)]
    public FP normalized_time;
    [FieldOffset(104)]
    public FP speed;
    [FieldOffset(112)]
    public FP time;
    [FieldOffset(120)]
    public FP to_length;
    [FieldOffset(12)]
    public Int32 to_state_id;
    [FieldOffset(128)]
    public FP to_state_last_time;
    [FieldOffset(136)]
    public FP to_state_normalized_time;
    [FieldOffset(144)]
    public FP to_state_time;
    [FieldOffset(152)]
    public FP transition_duration;
    [FieldOffset(16)]
    public Int32 transition_index;
    [FieldOffset(160)]
    public FP transition_time;
    public QListPtr<CustomAnimatorRuntimeVariable> AnimatorVariables {
      get {
        return new QListPtr<CustomAnimatorRuntimeVariable>(AnimatorVariablesPtr);
      }
      set {
        AnimatorVariablesPtr = value.Ptr;
      }
    }
    public QListPtr<AssetGuid> TriggeredStateBehaviours {
      get {
        return new QListPtr<AssetGuid>(TriggeredStateBehavioursPtr);
      }
      set {
        TriggeredStateBehavioursPtr = value.Ptr;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 131;
        hash = hash * 31 + AnimatorVariablesPtr.GetHashCode();
        hash = hash * 31 + TriggeredStateBehavioursPtr.GetHashCode();
        hash = hash * 31 + animatorGraph.GetHashCode();
        hash = hash * 31 + animator_blend_count.GetHashCode();
        hash = hash * 31 + current_state_id.GetHashCode();
        hash = hash * 31 + freeze.GetHashCode();
        hash = hash * 31 + from_length.GetHashCode();
        hash = hash * 31 + from_state_id.GetHashCode();
        hash = hash * 31 + from_state_last_time.GetHashCode();
        hash = hash * 31 + from_state_normalized_time.GetHashCode();
        hash = hash * 31 + from_state_time.GetHashCode();
        hash = hash * 31 + last_time.GetHashCode();
        hash = hash * 31 + length.GetHashCode();
        hash = hash * 31 + normalized_time.GetHashCode();
        hash = hash * 31 + speed.GetHashCode();
        hash = hash * 31 + time.GetHashCode();
        hash = hash * 31 + to_length.GetHashCode();
        hash = hash * 31 + to_state_id.GetHashCode();
        hash = hash * 31 + to_state_last_time.GetHashCode();
        hash = hash * 31 + to_state_normalized_time.GetHashCode();
        hash = hash * 31 + to_state_time.GetHashCode();
        hash = hash * 31 + transition_duration.GetHashCode();
        hash = hash * 31 + transition_index.GetHashCode();
        hash = hash * 31 + transition_time.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      AnimatorVariablesPtr = default;
      TriggeredStateBehavioursPtr = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (CustomAnimator*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CustomAnimator*)ptr;
        serializer.Stream.Serialize(&p->animator_blend_count);
        serializer.Stream.Serialize(&p->current_state_id);
        serializer.Stream.Serialize(&p->from_state_id);
        serializer.Stream.Serialize(&p->to_state_id);
        serializer.Stream.Serialize(&p->transition_index);
        QList<CustomAnimatorRuntimeVariable>.Serialize(&p->AnimatorVariablesPtr, serializer, Quantum.CustomAnimatorRuntimeVariable.Serialize);
        QList<AssetGuid>.Serialize(&p->TriggeredStateBehavioursPtr, serializer, AssetGuid.Serialize);
        QBoolean.Serialize(&p->freeze, serializer);
        Quantum.AssetRefCustomAnimatorGraph.Serialize(&p->animatorGraph, serializer);
        FP.Serialize(&p->from_length, serializer);
        FP.Serialize(&p->from_state_last_time, serializer);
        FP.Serialize(&p->from_state_normalized_time, serializer);
        FP.Serialize(&p->from_state_time, serializer);
        FP.Serialize(&p->last_time, serializer);
        FP.Serialize(&p->length, serializer);
        FP.Serialize(&p->normalized_time, serializer);
        FP.Serialize(&p->speed, serializer);
        FP.Serialize(&p->time, serializer);
        FP.Serialize(&p->to_length, serializer);
        FP.Serialize(&p->to_state_last_time, serializer);
        FP.Serialize(&p->to_state_normalized_time, serializer);
        FP.Serialize(&p->to_state_time, serializer);
        FP.Serialize(&p->transition_duration, serializer);
        FP.Serialize(&p->transition_time, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Dynamic_Collider : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 137;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Dynamic_Collider*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Dynamic_Trigger : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 139;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Dynamic_Trigger*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameSceneEntity : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    [FramePrinter.PtrQListAttribute(typeof(Int32))]
    private Ptr ParamsPtr;
    public QListPtr<Int32> Params {
      get {
        return new QListPtr<Int32>(ParamsPtr);
      }
      set {
        ParamsPtr = value.Ptr;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 149;
        hash = hash * 31 + ParamsPtr.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      ParamsPtr = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (GameSceneEntity*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameSceneEntity*)ptr;
        QList<Int32>.Serialize(&p->ParamsPtr, serializer, (v, s) => {{ s.Stream.Serialize((Int32*)v); }});
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameSceneTrigger : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    [FramePrinter.PtrQListAttribute(typeof(Int32))]
    private Ptr ParamsPtr;
    public QListPtr<Int32> Params {
      get {
        return new QListPtr<Int32>(ParamsPtr);
      }
      set {
        ParamsPtr = value.Ptr;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 151;
        hash = hash * 31 + ParamsPtr.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      ParamsPtr = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (GameSceneTrigger*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameSceneTrigger*)ptr;
        QList<Int32>.Serialize(&p->ParamsPtr, serializer, (v, s) => {{ s.Stream.Serialize((Int32*)v); }});
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HitBox : Quantum.IComponent {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean IsActive;
    [FieldOffset(8)]
    public EntityRef attacker;
    [FieldOffset(16)]
    public FPBounds3 bound;
    [FieldOffset(0)]
    public Int32 frameIndex;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 157;
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + attacker.GetHashCode();
        hash = hash * 31 + bound.GetHashCode();
        hash = hash * 31 + frameIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HitBox*)ptr;
        serializer.Stream.Serialize(&p->frameIndex);
        QBoolean.Serialize(&p->IsActive, serializer);
        EntityRef.Serialize(&p->attacker, serializer);
        FPBounds3.Serialize(&p->bound, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerFields : Quantum.IComponent {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    public PlayerState CurState;
    [FieldOffset(24)]
    public FP Gravity;
    [FieldOffset(12)]
    public QBoolean LastLeftButton;
    [FieldOffset(32)]
    public FP MoveSpeed;
    [FieldOffset(0)]
    public Int32 OwnerID;
    [FieldOffset(16)]
    public QBoolean hitByAttack;
    [FieldOffset(8)]
    [FramePrinter.PtrQListAttribute(typeof(FPBounds3))]
    private Ptr hurtBoxListPtr;
    [FieldOffset(56)]
    public FPBounds3 mainExtents;
    public QListPtr<FPBounds3> hurtBoxList {
      get {
        return new QListPtr<FPBounds3>(hurtBoxListPtr);
      }
      set {
        hurtBoxListPtr = value.Ptr;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 163;
        hash = hash * 31 + CurState.GetHashCode();
        hash = hash * 31 + Gravity.GetHashCode();
        hash = hash * 31 + LastLeftButton.GetHashCode();
        hash = hash * 31 + MoveSpeed.GetHashCode();
        hash = hash * 31 + OwnerID.GetHashCode();
        hash = hash * 31 + hitByAttack.GetHashCode();
        hash = hash * 31 + hurtBoxListPtr.GetHashCode();
        hash = hash * 31 + mainExtents.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      hurtBoxListPtr = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (PlayerFields*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerFields*)ptr;
        serializer.Stream.Serialize(&p->OwnerID);
        QList<FPBounds3>.Serialize(&p->hurtBoxListPtr, serializer, FPBounds3.Serialize);
        QBoolean.Serialize(&p->LastLeftButton, serializer);
        QBoolean.Serialize(&p->hitByAttack, serializer);
        FP.Serialize(&p->Gravity, serializer);
        FP.Serialize(&p->MoveSpeed, serializer);
        Quantum.PlayerState.Serialize(&p->CurState, serializer);
        FPBounds3.Serialize(&p->mainExtents, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SceneObjEntityAnimation : Quantum.IComponent {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [FramePrinter.PtrQListAttribute(typeof(AssetRefSceneObjAnimationClip))]
    private Ptr ClipsPtr;
    [FieldOffset(24)]
    public FPVector3 InitPosition;
    [FieldOffset(48)]
    public FPQuaternion InitRotate;
    [FieldOffset(16)]
    public FP PlayTime;
    [FieldOffset(0)]
    public Int32 nowClipIndex;
    public QListPtr<AssetRefSceneObjAnimationClip> Clips {
      get {
        return new QListPtr<AssetRefSceneObjAnimationClip>(ClipsPtr);
      }
      set {
        ClipsPtr = value.Ptr;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 167;
        hash = hash * 31 + ClipsPtr.GetHashCode();
        hash = hash * 31 + InitPosition.GetHashCode();
        hash = hash * 31 + InitRotate.GetHashCode();
        hash = hash * 31 + PlayTime.GetHashCode();
        hash = hash * 31 + nowClipIndex.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(Frame f, EntityRef entity) {
      ClipsPtr = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (SceneObjEntityAnimation*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SceneObjEntityAnimation*)ptr;
        serializer.Stream.Serialize(&p->nowClipIndex);
        QList<AssetRefSceneObjAnimationClip>.Serialize(&p->ClipsPtr, serializer, Quantum.AssetRefSceneObjAnimationClip.Serialize);
        FP.Serialize(&p->PlayTime, serializer);
        FPVector3.Serialize(&p->InitPosition, serializer);
        FPQuaternion.Serialize(&p->InitRotate, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpawnPoint : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 Index;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 173;
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpawnPoint*)ptr;
        serializer.Stream.Serialize(&p->Index);
    }
  }
  public unsafe partial class Frame {
    private ISignalOnAnimatorStateEnter[] _ISignalOnAnimatorStateEnterSystems;
    private ISignalOnAnimatorStateUpdate[] _ISignalOnAnimatorStateUpdateSystems;
    private ISignalOnAnimatorStateExit[] _ISignalOnAnimatorStateExitSystems;
    private ISignalOnHit[] _ISignalOnHitSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    static partial void InitStaticGen() {
      ComponentTypeId.Setup(() => {
        ComponentTypeId.Add<Quantum.CustomAnimator>(Quantum.CustomAnimator.Serialize, null, Quantum.CustomAnimator.OnRemoved, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.Dynamic_Collider>(Quantum.Dynamic_Collider.Serialize, null, null, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.Dynamic_Trigger>(Quantum.Dynamic_Trigger.Serialize, null, null, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.GameSceneEntity>(Quantum.GameSceneEntity.Serialize, null, Quantum.GameSceneEntity.OnRemoved, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.GameSceneTrigger>(Quantum.GameSceneTrigger.Serialize, null, Quantum.GameSceneTrigger.OnRemoved, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.HitBox>(Quantum.HitBox.Serialize, null, null, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.PlayerFields>(Quantum.PlayerFields.Serialize, null, Quantum.PlayerFields.OnRemoved, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.SceneObjEntityAnimation>(Quantum.SceneObjEntityAnimation.Serialize, null, Quantum.SceneObjEntityAnimation.OnRemoved, ComponentFlags.None);
        ComponentTypeId.Add<Quantum.SpawnPoint>(Quantum.SpawnPoint.Serialize, null, null, ComponentFlags.None);
      });
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities);
      _ISignalOnAnimatorStateEnterSystems = BuildSignalsArray<ISignalOnAnimatorStateEnter>();
      _ISignalOnAnimatorStateUpdateSystems = BuildSignalsArray<ISignalOnAnimatorStateUpdate>();
      _ISignalOnAnimatorStateExitSystems = BuildSignalsArray<ISignalOnAnimatorStateExit>();
      _ISignalOnHitSystems = BuildSignalsArray<ISignalOnHit>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.CustomAnimator>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CustomAnimator>();
      BuildSignalsArrayOnComponentAdded<Quantum.Dynamic_Collider>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Dynamic_Collider>();
      BuildSignalsArrayOnComponentAdded<Quantum.Dynamic_Trigger>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Dynamic_Trigger>();
      BuildSignalsArrayOnComponentAdded<Quantum.GameSceneEntity>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GameSceneEntity>();
      BuildSignalsArrayOnComponentAdded<Quantum.GameSceneTrigger>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GameSceneTrigger>();
      BuildSignalsArrayOnComponentAdded<Quantum.HitBox>();
      BuildSignalsArrayOnComponentRemoved<Quantum.HitBox>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerFields>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerFields>();
      BuildSignalsArrayOnComponentAdded<Quantum.SceneObjEntityAnimation>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SceneObjEntityAnimation>();
      BuildSignalsArrayOnComponentAdded<Quantum.SpawnPoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SpawnPoint>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    public void SetPlayerInput(Int32 player, Input input) {
      if ((uint)player >= (uint)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->Direction = input.Direction;
      i->PickThrowButton = i->PickThrowButton.Update(this.Number, input.PickThrowButton);
      i->JumpButton = i->JumpButton.Update(this.Number, input.JumpButton);
      i->LeftButton = i->LeftButton.Update(this.Number, input.LeftButton);
      i->RightButton = i->RightButton.Update(this.Number, input.RightButton);
    }
    public Input* GetPlayerInput(Int32 player) {
      if ((uint)player >= (uint)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    public unsafe partial struct FrameSignals {
      public void OnAnimatorStateEnter(EntityRef entity, CustomAnimator* animator) {
        var array = _f._ISignalOnAnimatorStateEnterSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (systems->IsSet(s.RuntimeIndex)) {
            s.OnAnimatorStateEnter(_f, entity, animator);
          }
        }
      }
      public void OnAnimatorStateUpdate(EntityRef entity, CustomAnimator* animator) {
        var array = _f._ISignalOnAnimatorStateUpdateSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (systems->IsSet(s.RuntimeIndex)) {
            s.OnAnimatorStateUpdate(_f, entity, animator);
          }
        }
      }
      public void OnAnimatorStateExit(EntityRef entity, CustomAnimator* animator) {
        var array = _f._ISignalOnAnimatorStateExitSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (systems->IsSet(s.RuntimeIndex)) {
            s.OnAnimatorStateExit(_f, entity, animator);
          }
        }
      }
      public void OnHit(EntityRef AttackEntity, EntityRef HitEntity) {
        var array = _f._ISignalOnHitSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (systems->IsSet(s.RuntimeIndex)) {
            s.OnHit(_f, AttackEntity, HitEntity);
          }
        }
      }
    }
    public unsafe partial struct FrameEvents {
      public const Int32 EVENT_TYPE_COUNT = 12;
      public static Int32 GetParentEventID(Int32 eventID) {
        switch (eventID) {
          default: return -1;
        }
      }
      public static System.Type GetEventType(Int32 eventID) {
        switch (eventID) {
          case EventOnGameEnd.ID: return typeof(EventOnGameEnd);
          case EventOnGamePlayerUpdate.ID: return typeof(EventOnGamePlayerUpdate);
          case EventOnGameRoundLoadMap.ID: return typeof(EventOnGameRoundLoadMap);
          case EventOnGameRoundLoadScene.ID: return typeof(EventOnGameRoundLoadScene);
          case EventOnGameRoundLoadPlayer.ID: return typeof(EventOnGameRoundLoadPlayer);
          case EventOnGameRoundEnter.ID: return typeof(EventOnGameRoundEnter);
          case EventOnGameRoundReady.ID: return typeof(EventOnGameRoundReady);
          case EventOnGameRoundRun.ID: return typeof(EventOnGameRoundRun);
          case EventOnGameRoundPlayerEnd.ID: return typeof(EventOnGameRoundPlayerEnd);
          case EventOnGameRoundFinish.ID: return typeof(EventOnGameRoundFinish);
          case EventOnGameRoundEnd.ID: return typeof(EventOnGameRoundEnd);
          case EventOnGameEvent.ID: return typeof(EventOnGameEvent);
          default: throw new System.ArgumentOutOfRangeException("eventID");
        }
      }
      public EventOnGameEnd OnGameEnd() {
        var ev = _f.Context.AcquireEvent<EventOnGameEnd>(EventOnGameEnd.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGamePlayerUpdate OnGamePlayerUpdate(PlayerRef Player) {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventOnGamePlayerUpdate>(EventOnGamePlayerUpdate.ID);
        ev.Player = Player;
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundLoadMap OnGameRoundLoadMap() {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundLoadMap>(EventOnGameRoundLoadMap.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundLoadScene OnGameRoundLoadScene(Int32 RoundIndex, Int32 GameType) {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundLoadScene>(EventOnGameRoundLoadScene.ID);
        ev.RoundIndex = RoundIndex;
        ev.GameType = GameType;
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundLoadPlayer OnGameRoundLoadPlayer(Int32 NeedLoadCount) {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundLoadPlayer>(EventOnGameRoundLoadPlayer.ID);
        ev.NeedLoadCount = NeedLoadCount;
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundEnter OnGameRoundEnter() {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundEnter>(EventOnGameRoundEnter.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundReady OnGameRoundReady() {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundReady>(EventOnGameRoundReady.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundRun OnGameRoundRun() {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundRun>(EventOnGameRoundRun.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundPlayerEnd OnGameRoundPlayerEnd(Int32 order, PlayerRef player) {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundPlayerEnd>(EventOnGameRoundPlayerEnd.ID);
        ev.order = order;
        ev.player = player;
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundFinish OnGameRoundFinish() {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundFinish>(EventOnGameRoundFinish.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameRoundEnd OnGameRoundEnd() {
        var ev = _f.Context.AcquireEvent<EventOnGameRoundEnd>(EventOnGameRoundEnd.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventOnGameEvent OnGameEvent(QStringUtf8_64 eventname, Ptr Params) {
        var ev = _f.Context.AcquireEvent<EventOnGameEvent>(EventOnGameEvent.ID);
        ev.eventname = eventname;
        ev.Params = Params;
        _f.AddEvent(ev);
        return ev;
      }
    }
    public unsafe partial struct FrameAssets {
      public SceneObjAnimationClip SceneObjAnimationClip(AssetRefSceneObjAnimationClip assetRef) {
         return _f.FindAsset<SceneObjAnimationClip>(assetRef.Id);
      }
      public CustomAnimatorGraph CustomAnimatorGraph(AssetRefCustomAnimatorGraph assetRef) {
         return _f.FindAsset<CustomAnimatorGraph>(assetRef.Id);
      }
      public CustomAnimatorBehaviour CustomAnimatorBehaviour(AssetRefCustomAnimatorBehaviour assetRef) {
         return _f.FindAsset<CustomAnimatorBehaviour>(assetRef.Id);
      }
      public GameAnimatorState GameAnimatorState(AssetRefGameAnimatorState assetRef) {
         return _f.FindAsset<GameAnimatorState>(assetRef.Id);
      }
      public RoundConfig RoundConfig(AssetRefRoundConfig assetRef) {
         return _f.FindAsset<RoundConfig>(assetRef.Id);
      }
    }
  }
  public unsafe interface ISignalOnAnimatorStateEnter : ISignal {
    void OnAnimatorStateEnter(Frame f, EntityRef entity, CustomAnimator* animator);
  }
  public unsafe interface ISignalOnAnimatorStateUpdate : ISignal {
    void OnAnimatorStateUpdate(Frame f, EntityRef entity, CustomAnimator* animator);
  }
  public unsafe interface ISignalOnAnimatorStateExit : ISignal {
    void OnAnimatorStateExit(Frame f, EntityRef entity, CustomAnimator* animator);
  }
  public unsafe interface ISignalOnHit : ISignal {
    void OnHit(Frame f, EntityRef AttackEntity, EntityRef HitEntity);
  }
  public unsafe partial class EventOnGameEnd : EventBase {
    public new const Int32 ID = 0;
    protected EventOnGameEnd(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameEnd() : 
        base(0, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 37;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGamePlayerUpdate : EventBase {
    public new const Int32 ID = 1;
    public PlayerRef Player;
    protected EventOnGamePlayerUpdate(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGamePlayerUpdate() : 
        base(1, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 41;
        hash = hash * 31 + Player.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundLoadMap : EventBase {
    public new const Int32 ID = 2;
    protected EventOnGameRoundLoadMap(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundLoadMap() : 
        base(2, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 43;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundLoadScene : EventBase {
    public new const Int32 ID = 3;
    public Int32 RoundIndex;
    public Int32 GameType;
    protected EventOnGameRoundLoadScene(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundLoadScene() : 
        base(3, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 47;
        hash = hash * 31 + RoundIndex.GetHashCode();
        hash = hash * 31 + GameType.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundLoadPlayer : EventBase {
    public new const Int32 ID = 4;
    public Int32 NeedLoadCount;
    protected EventOnGameRoundLoadPlayer(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundLoadPlayer() : 
        base(4, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 53;
        hash = hash * 31 + NeedLoadCount.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundEnter : EventBase {
    public new const Int32 ID = 5;
    protected EventOnGameRoundEnter(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundEnter() : 
        base(5, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 59;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundReady : EventBase {
    public new const Int32 ID = 6;
    protected EventOnGameRoundReady(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundReady() : 
        base(6, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 61;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundRun : EventBase {
    public new const Int32 ID = 7;
    protected EventOnGameRoundRun(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundRun() : 
        base(7, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 67;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundPlayerEnd : EventBase {
    public new const Int32 ID = 8;
    public Int32 order;
    public PlayerRef player;
    protected EventOnGameRoundPlayerEnd(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundPlayerEnd() : 
        base(8, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 71;
        hash = hash * 31 + order.GetHashCode();
        hash = hash * 31 + player.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundFinish : EventBase {
    public new const Int32 ID = 9;
    protected EventOnGameRoundFinish(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundFinish() : 
        base(9, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 73;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameRoundEnd : EventBase {
    public new const Int32 ID = 10;
    protected EventOnGameRoundEnd(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameRoundEnd() : 
        base(10, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 79;
        return hash;
      }
    }
  }
  public unsafe partial class EventOnGameEvent : EventBase {
    public new const Int32 ID = 11;
    public QStringUtf8_64 eventname;
    public Ptr Params;
    protected EventOnGameEvent(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventOnGameEvent() : 
        base(11, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 83;
        hash = hash * 31 + eventname.GetHashCode();
        hash = hash * 31 + Params.GetHashCode();
        return hash;
      }
    }
  }
  #region BitStreamExtensions
  static
  public unsafe partial class BitStreamExtensions {
    public static void Serialize(this IBitStream stream, ref AssetRefCustomAnimatorBehaviour value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefCustomAnimatorGraph value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefGameAnimatorState value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefRoundConfig value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefSceneObjAnimationClip value) {
      stream.Serialize(ref value.Id.Value);
    }
  }
  #endregion
  [System.SerializableAttribute()]
  public unsafe partial class SceneObjAnimationClip : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class CustomAnimatorGraph : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class CustomAnimatorBehaviour : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class GameAnimatorState : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class RoundConfig : AssetObject {
  }
  public unsafe partial class ComponentPrototypeVisitor : Prototypes.ComponentPrototypeVisitorBase {
    public virtual void Visit(Prototypes.CustomAnimator_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.Dynamic_Collider_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.Dynamic_Trigger_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.GameSceneEntity_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.GameSceneTrigger_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.HitBox_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.PlayerFields_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.SceneObjEntityAnimation_Prototype prototype) {
      VisitFallback(prototype);
    }
    public virtual void Visit(Prototypes.SpawnPoint_Prototype prototype) {
      VisitFallback(prototype);
    }
  }
  public static unsafe partial class Constants {
    public const Int32 PLAYER_COUNT = 8;
  }
  public unsafe partial class TypeRegistry {
    partial void AddGenerated() {
      Register(typeof(AssetGuid), AssetGuid.SIZE);
      Register(typeof(AssetRefCharacterController2DConfig), AssetRefCharacterController2DConfig.SIZE);
      Register(typeof(AssetRefCharacterController3DConfig), AssetRefCharacterController3DConfig.SIZE);
      Register(typeof(Quantum.AssetRefCustomAnimatorBehaviour), Quantum.AssetRefCustomAnimatorBehaviour.SIZE);
      Register(typeof(Quantum.AssetRefCustomAnimatorGraph), Quantum.AssetRefCustomAnimatorGraph.SIZE);
      Register(typeof(AssetRefEntityPrototype), AssetRefEntityPrototype.SIZE);
      Register(typeof(AssetRefEntityView), AssetRefEntityView.SIZE);
      Register(typeof(Quantum.AssetRefGameAnimatorState), Quantum.AssetRefGameAnimatorState.SIZE);
      Register(typeof(AssetRefMap), AssetRefMap.SIZE);
      Register(typeof(AssetRefNavMesh), AssetRefNavMesh.SIZE);
      Register(typeof(AssetRefNavMeshAgentConfig), AssetRefNavMeshAgentConfig.SIZE);
      Register(typeof(AssetRefPhysicsMaterial), AssetRefPhysicsMaterial.SIZE);
      Register(typeof(AssetRefPolygonCollider), AssetRefPolygonCollider.SIZE);
      Register(typeof(Quantum.AssetRefRoundConfig), Quantum.AssetRefRoundConfig.SIZE);
      Register(typeof(Quantum.AssetRefSceneObjAnimationClip), Quantum.AssetRefSceneObjAnimationClip.SIZE);
      Register(typeof(AssetRefTerrainCollider), AssetRefTerrainCollider.SIZE);
      Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      Register(typeof(Quantum.BitSet8), Quantum.BitSet8.SIZE);
      Register(typeof(Button), Button.SIZE);
      Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      Register(typeof(Quantum.CustomAnimator), Quantum.CustomAnimator.SIZE);
      Register(typeof(Quantum.CustomAnimatorRuntimeVariable), Quantum.CustomAnimatorRuntimeVariable.SIZE);
      Register(typeof(Quantum.Dynamic_Collider), Quantum.Dynamic_Collider.SIZE);
      Register(typeof(Quantum.Dynamic_Trigger), Quantum.Dynamic_Trigger.SIZE);
      Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      Register(typeof(EntityRef), EntityRef.SIZE);
      Register(typeof(Quantum.EnumPlayerState), 4);
      Register(typeof(FP), FP.SIZE);
      Register(typeof(FPBounds2), FPBounds2.SIZE);
      Register(typeof(FPBounds3), FPBounds3.SIZE);
      Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      Register(typeof(FPVector2), FPVector2.SIZE);
      Register(typeof(FPVector3), FPVector3.SIZE);
      Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      Register(typeof(Quantum.GamePlayer), Quantum.GamePlayer.SIZE);
      Register(typeof(Quantum.GameRoundData), Quantum.GameRoundData.SIZE);
      Register(typeof(Quantum.GameSceneEntity), Quantum.GameSceneEntity.SIZE);
      Register(typeof(Quantum.GameSceneTrigger), Quantum.GameSceneTrigger.SIZE);
      Register(typeof(Quantum.HitBox), Quantum.HitBox.SIZE);
      Register(typeof(Quantum.HurtBox), Quantum.HurtBox.SIZE);
      Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      Register(typeof(Quantum.InputButtons), 4);
      Register(typeof(LayerMask), LayerMask.SIZE);
      Register(typeof(MapEntityId), MapEntityId.SIZE);
      Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      Register(typeof(NullableFP), NullableFP.SIZE);
      Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      Register(typeof(Quantum.PlayerFields), Quantum.PlayerFields.SIZE);
      Register(typeof(PlayerRef), PlayerRef.SIZE);
      Register(typeof(Quantum.PlayerState), Quantum.PlayerState.SIZE);
      Register(typeof(Ptr), Ptr.SIZE);
      Register(typeof(QBoolean), QBoolean.SIZE);
      Register(typeof(Quantum.QStringUtf8_64), Quantum.QStringUtf8_64.SIZE);
      Register(typeof(RNGSession), RNGSession.SIZE);
      Register(typeof(Quantum.RoundState), 4);
      Register(typeof(Quantum.SceneObjEntityAnimation), Quantum.SceneObjEntityAnimation.SIZE);
      Register(typeof(Quantum.SecondRoundState), 4);
      Register(typeof(Quantum.SpawnPoint), Quantum.SpawnPoint.SIZE);
      Register(typeof(Transform2D), Transform2D.SIZE);
      Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      Register(typeof(Transform3D), Transform3D.SIZE);
      Register(typeof(View), View.SIZE);
      Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
  }
  public unsafe partial class FramePrinterGen {
    public static void EnsureNotStripped() {
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefCustomAnimatorBehaviour>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefCustomAnimatorGraph>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefGameAnimatorState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefRoundConfig>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefSceneObjAnimationClip>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EnumPlayerState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.RoundState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.SecondRoundState>();
    }
  }
}
namespace Quantum.Prototypes {
  using System;
  using System.Collections.Generic;
  using System.Runtime.InteropServices;
  using Photon.Deterministic;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Optional = Quantum.Inspector.OptionalAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  
  [System.SerializableAttribute()]
  [Prototype(typeof(EnumPlayerState))]
  public unsafe partial struct EnumPlayerState_Prototype {
    public Int32 Value;
    public static implicit operator EnumPlayerState(EnumPlayerState_Prototype value) {
        return (EnumPlayerState)value.Value;
    }
    public static implicit operator EnumPlayerState_Prototype(EnumPlayerState value) {
        return new EnumPlayerState_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(RoundState))]
  public unsafe partial struct RoundState_Prototype {
    public Int32 Value;
    public static implicit operator RoundState(RoundState_Prototype value) {
        return (RoundState)value.Value;
    }
    public static implicit operator RoundState_Prototype(RoundState value) {
        return new RoundState_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(SecondRoundState))]
  public unsafe partial struct SecondRoundState_Prototype {
    public Int32 Value;
    public static implicit operator SecondRoundState(SecondRoundState_Prototype value) {
        return (SecondRoundState)value.Value;
    }
    public static implicit operator SecondRoundState_Prototype(SecondRoundState value) {
        return new SecondRoundState_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(InputButtons))]
  public unsafe partial struct InputButtons_Prototype {
    public Int32 Value;
    public static implicit operator InputButtons(InputButtons_Prototype value) {
        return (InputButtons)value.Value;
    }
    public static implicit operator InputButtons_Prototype(InputButtons value) {
        return new InputButtons_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(CustomAnimator))]
  public unsafe sealed partial class CustomAnimator_Prototype : ComponentPrototype<CustomAnimator> {
    public AssetRefCustomAnimatorGraph animatorGraph;
    [DynamicCollectionAttribute()]
    public CustomAnimatorRuntimeVariable_Prototype[] AnimatorVariables = {};
    [DynamicCollectionAttribute()]
    public AssetGuid[] TriggeredStateBehaviours = {};
    public FP time;
    public FP normalized_time;
    public FP last_time;
    public FP length;
    public Int32 current_state_id;
    public QBoolean freeze;
    public FP speed;
    public Int32 from_state_id;
    public FP from_state_time;
    public FP from_state_last_time;
    public FP from_state_normalized_time;
    public FP from_length;
    public Int32 to_state_id;
    public FP to_state_time;
    public FP to_state_last_time;
    public FP to_state_normalized_time;
    public FP to_length;
    public Int32 transition_index;
    public FP transition_time;
    public FP transition_duration;
    public Int32 animator_blend_count;
    partial void MaterializeUser(Frame frame, ref CustomAnimator result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      CustomAnimator component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref CustomAnimator result, in PrototypeMaterializationContext context) {
      if (this.AnimatorVariables.Length == 0) {
        result.AnimatorVariables = default;
      } else {
        var list = frame.AllocateList<Quantum.CustomAnimatorRuntimeVariable>(this.AnimatorVariables.Length);
        for (int i = 0; i < this.AnimatorVariables.Length; ++i) {
          Quantum.CustomAnimatorRuntimeVariable tmp = default;
          this.AnimatorVariables[i].Materialize(frame, ref tmp, in context);
          list.Add(tmp);
        }
        result.AnimatorVariables = list;
      }
      if (this.TriggeredStateBehaviours.Length == 0) {
        result.TriggeredStateBehaviours = default;
      } else {
        var list = frame.AllocateList<AssetGuid>(this.TriggeredStateBehaviours.Length);
        for (int i = 0; i < this.TriggeredStateBehaviours.Length; ++i) {
          AssetGuid tmp = default;
          tmp = this.TriggeredStateBehaviours[i];
          list.Add(tmp);
        }
        result.TriggeredStateBehaviours = list;
      }
      result.animatorGraph = this.animatorGraph;
      result.animator_blend_count = this.animator_blend_count;
      result.current_state_id = this.current_state_id;
      result.freeze = this.freeze;
      result.from_length = this.from_length;
      result.from_state_id = this.from_state_id;
      result.from_state_last_time = this.from_state_last_time;
      result.from_state_normalized_time = this.from_state_normalized_time;
      result.from_state_time = this.from_state_time;
      result.last_time = this.last_time;
      result.length = this.length;
      result.normalized_time = this.normalized_time;
      result.speed = this.speed;
      result.time = this.time;
      result.to_length = this.to_length;
      result.to_state_id = this.to_state_id;
      result.to_state_last_time = this.to_state_last_time;
      result.to_state_normalized_time = this.to_state_normalized_time;
      result.to_state_time = this.to_state_time;
      result.transition_duration = this.transition_duration;
      result.transition_index = this.transition_index;
      result.transition_time = this.transition_time;
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(CustomAnimatorRuntimeVariable))]
  public unsafe sealed partial class CustomAnimatorRuntimeVariable_Prototype : UnionPrototype {
    public string _field_used_;
    public FP FPValue;
    public Int32 IntegerValue;
    public QBoolean BooleanValue;
    partial void MaterializeUser(Frame frame, ref CustomAnimatorRuntimeVariable result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref CustomAnimatorRuntimeVariable result, in PrototypeMaterializationContext context) {
      switch (_field_used_) {
        case "BOOLEANVALUE": *result.BooleanValue = this.BooleanValue; break;
        case "FPVALUE": *result.FPValue = this.FPValue; break;
        case "INTEGERVALUE": *result.IntegerValue = this.IntegerValue; break;
        case "": case null: break;
        default: PrototypeValidator.UnknownUnionField(_field_used_, in context); break;
      }
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(Dynamic_Collider))]
  public unsafe sealed partial class Dynamic_Collider_Prototype : ComponentPrototype<Dynamic_Collider> {
    [HideInInspector()]
    public Int32 _empty_prototype_dummy_field_;
    partial void MaterializeUser(Frame frame, ref Dynamic_Collider result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      Dynamic_Collider component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref Dynamic_Collider result, in PrototypeMaterializationContext context) {
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(Dynamic_Trigger))]
  public unsafe sealed partial class Dynamic_Trigger_Prototype : ComponentPrototype<Dynamic_Trigger> {
    [HideInInspector()]
    public Int32 _empty_prototype_dummy_field_;
    partial void MaterializeUser(Frame frame, ref Dynamic_Trigger result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      Dynamic_Trigger component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref Dynamic_Trigger result, in PrototypeMaterializationContext context) {
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(GamePlayer))]
  public unsafe sealed partial class GamePlayer_Prototype : StructPrototype {
    public PlayerRef Player;
    public Int64 roleid;
    [MaxStringByteCount(62, "UTF-8")]
    public string rolename;
    public Int32 headid;
    public Int32 avaterId;
    public Int32 hairId;
    public Int32 hairColor;
    public Int32 bodyColor;
    public QBoolean IsLoadMap;
    public QBoolean IsLoadScene;
    public QBoolean IsLoadPlayer;
    public QBoolean IsEnter;
    public QBoolean IsFinish;
    public MapEntityId PlayerEntity;
    partial void MaterializeUser(Frame frame, ref GamePlayer result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref GamePlayer result, in PrototypeMaterializationContext context) {
      result.IsEnter = this.IsEnter;
      result.IsFinish = this.IsFinish;
      result.IsLoadMap = this.IsLoadMap;
      result.IsLoadPlayer = this.IsLoadPlayer;
      result.IsLoadScene = this.IsLoadScene;
      result.Player = this.Player;
      PrototypeValidator.FindMapEntity(this.PlayerEntity, in context, out result.PlayerEntity);
      result.avaterId = this.avaterId;
      result.bodyColor = this.bodyColor;
      result.hairColor = this.hairColor;
      result.hairId = this.hairId;
      result.headid = this.headid;
      result.roleid = this.roleid;
      PrototypeValidator.AssignQStringUtf8(this.rolename, 64, in context, out result.rolename);
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(GameRoundData))]
  public unsafe sealed partial class GameRoundData_Prototype : StructPrototype {
    public Int32 RoundIndex;
    public Int32 GameType;
    public RoundState_Prototype State;
    public Int32 SecondRound;
    public SecondRoundState_Prototype SecondRoundState;
    public FP SecondRoundTime;
    public FP ReadyTime;
    public FP Timer;
    [DynamicCollectionAttribute()]
    public MapEntityId[] SceneEntitys = {};
    [DynamicCollectionAttribute()]
    public PlayerRef[] EndPlayers = {};
    partial void MaterializeUser(Frame frame, ref GameRoundData result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref GameRoundData result, in PrototypeMaterializationContext context) {
      if (this.EndPlayers.Length == 0) {
        result.EndPlayers = default;
      } else {
        var list = frame.AllocateList<PlayerRef>(this.EndPlayers.Length);
        for (int i = 0; i < this.EndPlayers.Length; ++i) {
          PlayerRef tmp = default;
          tmp = this.EndPlayers[i];
          list.Add(tmp);
        }
        result.EndPlayers = list;
      }
      result.GameType = this.GameType;
      result.ReadyTime = this.ReadyTime;
      result.RoundIndex = this.RoundIndex;
      if (this.SceneEntitys.Length == 0) {
        result.SceneEntitys = default;
      } else {
        var list = frame.AllocateList<EntityRef>(this.SceneEntitys.Length);
        for (int i = 0; i < this.SceneEntitys.Length; ++i) {
          EntityRef tmp = default;
          PrototypeValidator.FindMapEntity(this.SceneEntitys[i], in context, out tmp);
          list.Add(tmp);
        }
        result.SceneEntitys = list;
      }
      result.SecondRound = this.SecondRound;
      result.SecondRoundState = this.SecondRoundState;
      result.SecondRoundTime = this.SecondRoundTime;
      result.State = this.State;
      result.Timer = this.Timer;
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(GameSceneEntity))]
  public unsafe sealed partial class GameSceneEntity_Prototype : ComponentPrototype<GameSceneEntity> {
    [DynamicCollectionAttribute()]
    public Int32[] Params = {};
    partial void MaterializeUser(Frame frame, ref GameSceneEntity result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      GameSceneEntity component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref GameSceneEntity result, in PrototypeMaterializationContext context) {
      if (this.Params.Length == 0) {
        result.Params = default;
      } else {
        var list = frame.AllocateList<Int32>(this.Params.Length);
        for (int i = 0; i < this.Params.Length; ++i) {
          Int32 tmp = default;
          tmp = this.Params[i];
          list.Add(tmp);
        }
        result.Params = list;
      }
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(GameSceneTrigger))]
  public unsafe sealed partial class GameSceneTrigger_Prototype : ComponentPrototype<GameSceneTrigger> {
    [DynamicCollectionAttribute()]
    public Int32[] Params = {};
    partial void MaterializeUser(Frame frame, ref GameSceneTrigger result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      GameSceneTrigger component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref GameSceneTrigger result, in PrototypeMaterializationContext context) {
      if (this.Params.Length == 0) {
        result.Params = default;
      } else {
        var list = frame.AllocateList<Int32>(this.Params.Length);
        for (int i = 0; i < this.Params.Length; ++i) {
          Int32 tmp = default;
          tmp = this.Params[i];
          list.Add(tmp);
        }
        result.Params = list;
      }
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(HitBox))]
  public unsafe sealed partial class HitBox_Prototype : ComponentPrototype<HitBox> {
    public MapEntityId attacker;
    public Int32 frameIndex;
    public FPBounds3 bound;
    public QBoolean IsActive;
    partial void MaterializeUser(Frame frame, ref HitBox result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      HitBox component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref HitBox result, in PrototypeMaterializationContext context) {
      result.IsActive = this.IsActive;
      PrototypeValidator.FindMapEntity(this.attacker, in context, out result.attacker);
      result.bound = this.bound;
      result.frameIndex = this.frameIndex;
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(HurtBox))]
  public unsafe sealed partial class HurtBox_Prototype : StructPrototype {
    public Int32 frameIndex;
    public FPBounds2 bound;
    partial void MaterializeUser(Frame frame, ref HurtBox result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref HurtBox result, in PrototypeMaterializationContext context) {
      result.bound = this.bound;
      result.frameIndex = this.frameIndex;
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(Input))]
  public unsafe sealed partial class Input_Prototype : StructPrototype {
    public FPVector2 Direction;
    public Button PickThrowButton;
    public Button JumpButton;
    public Button LeftButton;
    public Button RightButton;
    partial void MaterializeUser(Frame frame, ref Input result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref Input result, in PrototypeMaterializationContext context) {
      result.Direction = this.Direction;
      result.JumpButton = this.JumpButton;
      result.LeftButton = this.LeftButton;
      result.PickThrowButton = this.PickThrowButton;
      result.RightButton = this.RightButton;
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(PlayerFields))]
  public unsafe sealed partial class PlayerFields_Prototype : ComponentPrototype<PlayerFields> {
    public Int32 OwnerID;
    public PlayerState_Prototype CurState;
    public QBoolean LastLeftButton;
    public FP MoveSpeed;
    public FP Gravity;
    public QBoolean hitByAttack;
    public FPBounds3 mainExtents;
    [DynamicCollectionAttribute()]
    public FPBounds3[] hurtBoxList = {};
    partial void MaterializeUser(Frame frame, ref PlayerFields result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      PlayerFields component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref PlayerFields result, in PrototypeMaterializationContext context) {
      this.CurState.Materialize(frame, ref result.CurState, in context);
      result.Gravity = this.Gravity;
      result.LastLeftButton = this.LastLeftButton;
      result.MoveSpeed = this.MoveSpeed;
      result.OwnerID = this.OwnerID;
      result.hitByAttack = this.hitByAttack;
      if (this.hurtBoxList.Length == 0) {
        result.hurtBoxList = default;
      } else {
        var list = frame.AllocateList<FPBounds3>(this.hurtBoxList.Length);
        for (int i = 0; i < this.hurtBoxList.Length; ++i) {
          FPBounds3 tmp = default;
          tmp = this.hurtBoxList[i];
          list.Add(tmp);
        }
        result.hurtBoxList = list;
      }
      result.mainExtents = this.mainExtents;
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(PlayerState))]
  public unsafe sealed partial class PlayerState_Prototype : StructPrototype {
    public EnumPlayerState_Prototype state;
    public FP Time;
    partial void MaterializeUser(Frame frame, ref PlayerState result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref PlayerState result, in PrototypeMaterializationContext context) {
      result.Time = this.Time;
      result.state = this.state;
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(SceneObjEntityAnimation))]
  public unsafe sealed partial class SceneObjEntityAnimation_Prototype : ComponentPrototype<SceneObjEntityAnimation> {
    public FP PlayTime;
    [DynamicCollectionAttribute()]
    public AssetRefSceneObjAnimationClip[] Clips = {};
    public Int32 nowClipIndex;
    public FPVector3 InitPosition;
    [DegreesAttribute()]
    public FPVector3 InitRotate;
    partial void MaterializeUser(Frame frame, ref SceneObjEntityAnimation result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      SceneObjEntityAnimation component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref SceneObjEntityAnimation result, in PrototypeMaterializationContext context) {
      if (this.Clips.Length == 0) {
        result.Clips = default;
      } else {
        var list = frame.AllocateList<Quantum.AssetRefSceneObjAnimationClip>(this.Clips.Length);
        for (int i = 0; i < this.Clips.Length; ++i) {
          Quantum.AssetRefSceneObjAnimationClip tmp = default;
          tmp = this.Clips[i];
          list.Add(tmp);
        }
        result.Clips = list;
      }
      result.InitPosition = this.InitPosition;
      result.InitRotate = FPQuaternion.Euler(this.InitRotate);
      result.PlayTime = this.PlayTime;
      result.nowClipIndex = this.nowClipIndex;
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(SpawnPoint))]
  public unsafe sealed partial class SpawnPoint_Prototype : ComponentPrototype<SpawnPoint> {
    public Int32 Index;
    partial void MaterializeUser(Frame frame, ref SpawnPoint result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      SpawnPoint component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref SpawnPoint result, in PrototypeMaterializationContext context) {
      result.Index = this.Index;
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  public unsafe partial class FlatEntityPrototypeContainer {
    [ArrayLength(0, 1)]
    public List<Prototypes.CustomAnimator_Prototype> CustomAnimator;
    [ArrayLength(0, 1)]
    public List<Prototypes.Dynamic_Collider_Prototype> Dynamic_Collider;
    [ArrayLength(0, 1)]
    public List<Prototypes.Dynamic_Trigger_Prototype> Dynamic_Trigger;
    [ArrayLength(0, 1)]
    public List<Prototypes.GameSceneEntity_Prototype> GameSceneEntity;
    [ArrayLength(0, 1)]
    public List<Prototypes.GameSceneTrigger_Prototype> GameSceneTrigger;
    [ArrayLength(0, 1)]
    public List<Prototypes.HitBox_Prototype> HitBox;
    [ArrayLength(0, 1)]
    public List<Prototypes.PlayerFields_Prototype> PlayerFields;
    [ArrayLength(0, 1)]
    public List<Prototypes.SceneObjEntityAnimation_Prototype> SceneObjEntityAnimation;
    [ArrayLength(0, 1)]
    public List<Prototypes.SpawnPoint_Prototype> SpawnPoint;
    partial void CollectGen(List<ComponentPrototype> target) {
      Collect(CustomAnimator, target);
      Collect(Dynamic_Collider, target);
      Collect(Dynamic_Trigger, target);
      Collect(GameSceneEntity, target);
      Collect(GameSceneTrigger, target);
      Collect(HitBox, target);
      Collect(PlayerFields, target);
      Collect(SceneObjEntityAnimation, target);
      Collect(SpawnPoint, target);
    }
    public unsafe partial class StoreVisitor {
      public override void Visit(Prototypes.CustomAnimator_Prototype prototype) {
        Storage.Store(prototype, ref Storage.CustomAnimator);
      }
      public override void Visit(Prototypes.Dynamic_Collider_Prototype prototype) {
        Storage.Store(prototype, ref Storage.Dynamic_Collider);
      }
      public override void Visit(Prototypes.Dynamic_Trigger_Prototype prototype) {
        Storage.Store(prototype, ref Storage.Dynamic_Trigger);
      }
      public override void Visit(Prototypes.GameSceneEntity_Prototype prototype) {
        Storage.Store(prototype, ref Storage.GameSceneEntity);
      }
      public override void Visit(Prototypes.GameSceneTrigger_Prototype prototype) {
        Storage.Store(prototype, ref Storage.GameSceneTrigger);
      }
      public override void Visit(Prototypes.HitBox_Prototype prototype) {
        Storage.Store(prototype, ref Storage.HitBox);
      }
      public override void Visit(Prototypes.PlayerFields_Prototype prototype) {
        Storage.Store(prototype, ref Storage.PlayerFields);
      }
      public override void Visit(Prototypes.SceneObjEntityAnimation_Prototype prototype) {
        Storage.Store(prototype, ref Storage.SceneObjEntityAnimation);
      }
      public override void Visit(Prototypes.SpawnPoint_Prototype prototype) {
        Storage.Store(prototype, ref Storage.SpawnPoint);
      }
    }
  }
}
#pragma warning restore 0649
#pragma warning restore 1522
#pragma warning restore 0414
#pragma warning restore 0219
#pragma warning restore 0109
